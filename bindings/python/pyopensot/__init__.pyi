from typing import ClassVar, overload, TypeVar
from typing import Literal

import numpy

M = TypeVar("M", bound=int)
N = TypeVar("N", bound=int)

BOUND: ConstraintType
CONSTRAINT: ConstraintType
EQUALITIES_TO_INEQUALITIES: AggregationPolicy
GLPK: solver_back_ends
ODYS: solver_back_ends
OSQP: solver_back_ends
UNILATERAL_TO_BILATERAL: AggregationPolicy
eiQuadProg: solver_back_ends
proxQP: solver_back_ends
qpOASES: solver_back_ends
qpSWIFT: solver_back_ends


class AffineHelper:
    @overload
    def __init__(self) -> None: ...

    @overload
    def __init__(self, arg0: int, arg1: int) -> None: ...

    @overload
    def __init__(self, arg0: numpy.ndarray[tuple[M, N], numpy.dtype[numpy.float64]],
                 arg1: numpy.ndarray[tuple[M, Literal[1]], numpy.dtype[numpy.float64]]) -> None: ...

    def getInputSize(self) -> int: ...

    def getM(self) -> numpy.ndarray[tuple[M, N], numpy.dtype[numpy.float64]]: ...

    def getOutputSize(self) -> int: ...

    def getValue(self, arg0: numpy.ndarray[tuple[M, Literal[1]], numpy.dtype[numpy.float64]]) -> \
    numpy.ndarray[tuple[M, Literal[1]], numpy.dtype[numpy.float64]]: ...

    def getq(self) -> numpy.ndarray[tuple[M, Literal[1]], numpy.dtype[numpy.float64]]: ...

    def set(self, arg0: numpy.ndarray[tuple[M, N], numpy.dtype[numpy.float64]],
            arg1: numpy.ndarray[tuple[M, Literal[1]], numpy.dtype[numpy.float64]]) -> None: ...

    def setM(self, arg0: numpy.ndarray[tuple[M, N], numpy.dtype[numpy.float64]]) -> None: ...

    @overload
    def setZero(self) -> None: ...

    @overload
    def setZero(self, arg0: int, arg1: int) -> None: ...

    def setq(self,
             arg0: numpy.ndarray[tuple[M, Literal[1]], numpy.dtype[numpy.float64]]) -> None: ...

    def update(self) -> None: ...

    @overload
    def __add__(self, arg0: AffineHelper) -> AffineHelper: ...

    @overload
    def __add__(self, arg0: numpy.ndarray[
        tuple[M, Literal[1]], numpy.dtype[numpy.float64]]) -> AffineHelper: ...

    def __mul__(self, arg0: AffineHelper) -> AffineHelper: ...

    @overload
    def __sub__(self, arg0: AffineHelper) -> AffineHelper: ...

    @overload
    def __sub__(self, arg0: numpy.ndarray[
        tuple[M, Literal[1]], numpy.dtype[numpy.float64]]) -> AffineHelper: ...

    def __truediv__(self, arg0: AffineHelper) -> AffineHelper: ...


class AggregatedConstraint(Constraint):
    @overload
    def __init__(self, arg0: list[Constraint], arg1: int, aggregationPolicy: int = ...) -> None: ...

    @overload
    def __init__(self, arg0: Constraint, arg1: Constraint, arg2: int,
                 aggregationPolicy: int = ...) -> None: ...

    def getConstraintsList(self) -> list[Constraint]: ...

    def update(self) -> None: ...


class AggregatedTask(Task):
    @overload
    def __init__(self, arg0: list[Task], arg1: int) -> None: ...

    @overload
    def __init__(self, arg0: Task, arg1: int) -> None: ...

    @overload
    def __init__(self, arg0: Task, arg1: Task, arg2: int) -> None: ...

    def getAggregatedConstraints(self) -> list[Constraint]: ...

    def getOwnConstraints(self) -> list[Constraint]: ...

    def getTaskList(self) -> list[Task]: ...

    def setLambda(self, arg0: float) -> None: ...

    def setWeight(self, arg0: numpy.ndarray[tuple[M, N], numpy.dtype[numpy.float64]]) -> None: ...


class AggregationPolicy:
    __members__: ClassVar[dict] = ...  # read-only
    EQUALITIES_TO_INEQUALITIES: ClassVar[AggregationPolicy] = ...
    UNILATERAL_TO_BILATERAL: ClassVar[AggregationPolicy] = ...
    __entries: ClassVar[dict] = ...

    def __init__(self, value: int) -> None: ...

    def __eq__(self, other: object) -> bool: ...

    def __hash__(self) -> int: ...

    def __index__(self) -> int: ...

    def __int__(self) -> int: ...

    def __ne__(self, other: object) -> bool: ...

    @property
    def name(self) -> str: ...

    @property
    def value(self) -> int: ...


class AutoStack:
    @overload
    def __init__(self, arg0: int) -> None: ...

    @overload
    def __init__(self, arg0: Task) -> None: ...

    @overload
    def __init__(self, arg0: AutoStack) -> None: ...

    @overload
    def __init__(self, arg0: Task, arg1: list[Constraint]) -> None: ...

    @overload
    def __init__(self, arg0: list[Task]) -> None: ...

    @overload
    def __init__(self, arg0: list[Task], arg1: list[Constraint]) -> None: ...

    def checkConsistency(self) -> bool: ...

    def getBounds(self) -> Constraint: ...

    def getBoundsList(self) -> list[Constraint]: ...

    def getRegularisationTask(self) -> Task: ...

    def getStack(self) -> list[Task]: ...

    def getTask(self, arg0: str) -> Task: ...

    def log(self, arg0) -> None: ...

    def setBoundsAggregationPolicy(self, arg0: int) -> None: ...

    def setRegularisationTask(self, arg0: Task) -> None: ...

    def update(self) -> None: ...

    @overload
    def __lshift__(self, arg0: Constraint) -> AutoStack: ...

    @overload
    def __lshift__(self, arg0: Task) -> AutoStack: ...

    @overload
    def __truediv__(self, arg0: Task) -> AutoStack: ...

    @overload
    def __truediv__(self, arg0: AutoStack) -> AutoStack: ...

    def __mul__(self, other: float) -> AutoStack: ...

    def __add__(self, other: AutoStack) -> AutoStack: ...

    def __mod__(self, other: AutoStack) -> AutoStack: ...


class Constraint:
    def __init__(self, arg0: str, arg1: int) -> None: ...

    def checkConsistency(self) -> bool: ...

    def getAeq(self) -> numpy.ndarray[tuple[M, N], numpy.dtype[numpy.float64]]: ...

    def getAineq(self) -> numpy.ndarray[tuple[M, N], numpy.dtype[numpy.float64]]: ...

    def getConstraintID(self) -> str: ...

    def getLowerBound(self) -> numpy.ndarray[tuple[M, Literal[1]], numpy.dtype[numpy.float64]]: ...

    def getUpperBound(self) -> numpy.ndarray[tuple[M, Literal[1]], numpy.dtype[numpy.float64]]: ...

    def getXSize(self) -> int: ...

    def getbLowerBound(self) -> numpy.ndarray[tuple[M, Literal[1]], numpy.dtype[numpy.float64]]: ...

    def getbUpperBound(self) -> numpy.ndarray[tuple[M, Literal[1]], numpy.dtype[numpy.float64]]: ...

    def getbeq(self) -> numpy.ndarray[tuple[M, Literal[1]], numpy.dtype[numpy.float64]]: ...

    def hasBounds(self) -> bool: ...

    def isBilateralConstraint(self) -> bool: ...

    def isBound(self) -> bool: ...

    def isConstraint(self) -> bool: ...

    def isEqualityConstraint(self) -> bool: ...

    def isInequalityConstraint(self) -> bool: ...

    def isUnilateralConstraint(self) -> bool: ...

    def log(self, arg0) -> None: ...

    def update(self) -> None: ...

    def __mod__(self, other): ...


class ConstraintType:
    __members__: ClassVar[dict] = ...  # read-only
    BOUND: ClassVar[ConstraintType] = ...
    CONSTRAINT: ClassVar[ConstraintType] = ...
    __entries: ClassVar[dict] = ...

    def __init__(self, value: int) -> None: ...

    def __eq__(self, other: object) -> bool: ...

    def __hash__(self) -> int: ...

    def __index__(self) -> int: ...

    def __int__(self) -> int: ...

    def __ne__(self, other: object) -> bool: ...

    @property
    def name(self) -> str: ...

    @property
    def value(self) -> int: ...


class GenericConstraint(Constraint):
    @overload
    def __init__(self, arg0: str,
                 arg1: numpy.ndarray[tuple[M, Literal[1]], numpy.dtype[numpy.float64]],
                 arg2: numpy.ndarray[tuple[M, Literal[1]], numpy.dtype[numpy.float64]],
                 arg3: int) -> None: ...

    @overload
    def __init__(self, arg0: str, arg1: AffineHelper,
                 arg2: numpy.ndarray[tuple[M, Literal[1]], numpy.dtype[numpy.float64]],
                 arg3: numpy.ndarray[tuple[M, Literal[1]], numpy.dtype[numpy.float64]],
                 arg4: ConstraintType) -> None: ...

    def getType(self) -> ConstraintType: ...

    def setBounds(self, arg0: numpy.ndarray[tuple[M, Literal[1]], numpy.dtype[numpy.float64]],
                  arg1: numpy.ndarray[
                      tuple[M, Literal[1]], numpy.dtype[numpy.float64]]) -> bool: ...

    def setConstraint(self, arg0: AffineHelper,
                      arg1: numpy.ndarray[tuple[M, Literal[1]], numpy.dtype[numpy.float64]],
                      arg2: numpy.ndarray[
                          tuple[M, Literal[1]], numpy.dtype[numpy.float64]]) -> bool: ...

    def update(self) -> None: ...


class GenericTask(Task):
    @overload
    def __init__(self, arg0: str, arg1: numpy.ndarray[tuple[M, N], numpy.dtype[numpy.float64]],
                 arg2: numpy.ndarray[tuple[M, Literal[1]], numpy.dtype[numpy.float64]]) -> None: ...

    @overload
    def __init__(self, arg0: str, arg1: numpy.ndarray[tuple[M, N], numpy.dtype[numpy.float64]],
                 arg2: numpy.ndarray[tuple[M, Literal[1]], numpy.dtype[numpy.float64]],
                 arg3: AffineHelper) -> None: ...

    def setA(self, arg0: numpy.ndarray[tuple[M, N], numpy.dtype[numpy.float64]]) -> bool: ...

    def setAb(self, arg0: numpy.ndarray[tuple[M, N], numpy.dtype[numpy.float64]],
              arg1: numpy.ndarray[tuple[M, Literal[1]], numpy.dtype[numpy.float64]]) -> bool: ...

    def setHessianType(self, arg0) -> None: ...

    def setb(self,
             arg0: numpy.ndarray[tuple[M, Literal[1]], numpy.dtype[numpy.float64]]) -> bool: ...

    def setc(self,
             arg0: numpy.ndarray[tuple[M, Literal[1]], numpy.dtype[numpy.float64]]) -> bool: ...


class HCOD(Solver):
    @overload
    def __init__(self, arg0: AutoStack, arg1: float) -> None: ...

    @overload
    def __init__(self, arg0: list[Task], arg1: Constraint, arg2: float) -> None: ...

    def getDisableWeightsComputation(self) -> bool: ...

    def printSOT(self) -> None: ...

    def setDamping(self, arg0: float) -> None: ...

    def setDisableWeightsComputation(self, arg0: bool) -> None: ...

    def solve(self) -> numpy.ndarray[tuple[N, Literal[1]], numpy.dtype[numpy.float64]]: ...


class OptvarHelper:
    def __init__(self, arg0: dict) -> None: ...

    def getAllVariables(self) -> list[AffineHelper]: ...

    def getSize(self) -> int: ...

    def getVariable(self, arg0: str) -> AffineHelper: ...


class Solver:
    @overload
    def __init__(self, arg0: list[Task]) -> None: ...

    @overload
    def __init__(self, arg0: list[Task], arg1: Constraint) -> None: ...

    @overload
    def __init__(self, arg0: list[Task], arg1: Constraint, arg2: Constraint) -> None: ...

    def getSolverID(self) -> str: ...

    def log(self, arg0) -> None: ...

    def setSolverID(self, arg0: str) -> None: ...

    def solve(self) -> numpy.ndarray[tuple[N, Literal[1]], numpy.dtype[numpy.float64]]: ...


class SubConstraint(Constraint):
    def __init__(self, arg0: Constraint, arg1: list[int]) -> None: ...

    def update(self) -> None: ...


class SubTask(Task):
    def __init__(self, arg0: Task, arg1: list[int]) -> None: ...

    @staticmethod
    def asSubTask(arg0: Task) -> SubTask: ...

    def getActiveJointsMask(self) -> list[bool]: ...

    def getConstraints(self) -> list[Constraint]: ...

    def getTask(self) -> Task: ...

    def getTaskSize(self) -> int: ...

    @staticmethod
    def isSubTask(arg0: Task) -> bool: ...

    def setActiveJointsMask(self, arg0: list[bool]) -> bool: ...

    def setWeight(self, arg0: numpy.ndarray[tuple[M, N], numpy.dtype[numpy.float64]]) -> None: ...


class Task:
    def __init__(self, arg0: str, arg1: int) -> None: ...

    def checkConsistency(self) -> bool: ...

    def computeCost(self, arg0: numpy.ndarray[
        tuple[M, Literal[1]], numpy.dtype[numpy.float64]]) -> float: ...

    def getA(self) -> numpy.ndarray[tuple[M, N], numpy.dtype[numpy.float64]]: ...

    def getATranspose(self) -> numpy.ndarray[tuple[M, N], numpy.dtype[numpy.float64]]: ...

    def getActiveJointsMask(self) -> list[bool]: ...

    def getConstraints(self, *args, **kwargs): ...

    def getHessianAtype(self, *args, **kwargs): ...

    def getLambda(self) -> float: ...

    def getTaskID(self) -> str: ...

    def getTaskSize(self) -> int: ...

    def getWA(self) -> numpy.ndarray[tuple[M, N], numpy.dtype[numpy.float64]]: ...

    def getWb(self) -> numpy.ndarray[tuple[M, Literal[1]], numpy.dtype[numpy.float64]]: ...

    def getWeight(self) -> numpy.ndarray[tuple[M, N], numpy.dtype[numpy.float64]]: ...

    def getWeightIsDiagonalFlag(self) -> bool: ...

    def getXSize(self) -> int: ...

    def getb(self) -> numpy.ndarray[tuple[M, Literal[1]], numpy.dtype[numpy.float64]]: ...

    def getc(self) -> numpy.ndarray[tuple[M, Literal[1]], numpy.dtype[numpy.float64]]: ...

    def isActive(self) -> bool: ...

    def log(self, arg0) -> None: ...

    def setActive(self, arg0: bool) -> None: ...

    def setActiveJointsMask(self, arg0: list[bool]) -> bool: ...

    def setLambda(self, arg0: float) -> None: ...

    def setWeight(self, weight: numpy.ndarray[tuple[M, N], numpy.dtype[numpy.float64]]) -> None: ...

    def setWeightIsDiagonalFlag(self, arg0: bool) -> None: ...

    def update(self) -> None: ...

    def __add__(self, other): ...

    @overload
    def __lshift__(self, arg0: Task) -> Task: ...

    @overload
    def __lshift__(self, arg0: Constraint) -> Task: ...

    def __mod__(self, other): ...

    def __rmul__(self, arg0: float) -> Task: ...

    def __truediv__(self, other): ...


class eHQP(Solver):
    def __init__(self, arg0: list[Task]) -> None: ...

    def getSigmaMin(self) -> float: ...

    def setSigmaMin(self, arg0: float) -> None: ...

    def solve(self) -> numpy.ndarray[tuple[N, Literal[1]], numpy.dtype[numpy.float64]]: ...


class iHQP(Solver):
    @overload
    def __init__(self, arg0: AutoStack, eps_regularisation: float = ...,
                 be_solver: solver_back_ends = ...) -> None: ...

    @overload
    def __init__(self, arg0: AutoStack, arg1: float, arg2: list[solver_back_ends]) -> None: ...

    @overload
    def __init__(self, arg0: list[Task], eps_regularisation: float = ...,
                 be_solver: solver_back_ends = ...) -> None: ...

    @overload
    def __init__(self, arg0: list[Task], arg1: float, arg2: list[solver_back_ends]) -> None: ...

    @overload
    def __init__(self, arg0: list[Task], arg1: Constraint, eps_regularisation: float = ...,
                 be_solver: solver_back_ends = ...) -> None: ...

    @overload
    def __init__(self, arg0: list[Task], arg1: Constraint, arg2: float,
                 arg3: list[solver_back_ends]) -> None: ...

    @overload
    def __init__(self, arg0: list[Task], arg1: Constraint, arg2: Constraint,
                 eps_regularisation: float = ..., be_solver: solver_back_ends = ...) -> None: ...

    @overload
    def __init__(self, arg0: list[Task], arg1: Constraint, arg2: Constraint, arg3: float,
                 arg4: list[solver_back_ends]) -> None: ...

    def activateAllStacks(self) -> None: ...

    def getBackEnd(self, arg0: int, arg1) -> bool: ...

    def getBackEndName(self, arg0: int) -> str: ...

    def getNumberOfTasks(self) -> int: ...

    def getObjective(self, arg0: int, arg1: float) -> bool: ...

    def setActiveStack(self, arg0: int, arg1: bool) -> None: ...

    @overload
    def setEpsRegularisation(self, arg0: float, arg1: int) -> bool: ...

    @overload
    def setEpsRegularisation(self, arg0: float) -> bool: ...

    def solve(self) -> numpy.ndarray[tuple[N, Literal[1]], numpy.dtype[numpy.float64]]: ...


class nHQP(Solver):
    def __init__(self, arg0: list[Task], arg1: Constraint, arg2: float,
                 be_solver: solver_back_ends = ...) -> None: ...

    @overload
    def setMinSingularValueRatio(self, arg0: float) -> None: ...

    @overload
    def setMinSingularValueRatio(self, arg0: list[float]) -> None: ...

    @overload
    def setPerformAbRegularization(self, arg0: int, arg1: bool) -> None: ...

    @overload
    def setPerformAbRegularization(self, arg0: bool) -> None: ...

    @overload
    def setPerformSelectiveNullSpaceRegularization(self, arg0: int, arg1: bool) -> None: ...

    @overload
    def setPerformSelectiveNullSpaceRegularization(self, arg0: bool) -> None: ...

    def solve(self) -> numpy.ndarray[tuple[N, Literal[1]], numpy.dtype[numpy.float64]]: ...


class solver_back_ends:
    __members__: ClassVar[dict] = ...  # read-only
    GLPK: ClassVar[solver_back_ends] = ...
    ODYS: ClassVar[solver_back_ends] = ...
    OSQP: ClassVar[solver_back_ends] = ...
    __entries: ClassVar[dict] = ...
    eiQuadProg: ClassVar[solver_back_ends] = ...
    proxQP: ClassVar[solver_back_ends] = ...
    qpOASES: ClassVar[solver_back_ends] = ...
    qpSWIFT: ClassVar[solver_back_ends] = ...

    def __init__(self, value: int) -> None: ...

    def __eq__(self, other: object) -> bool: ...

    def __hash__(self) -> int: ...

    def __index__(self) -> int: ...

    def __int__(self) -> int: ...

    def __ne__(self, other: object) -> bool: ...

    @property
    def name(self) -> str: ...

    @property
    def value(self) -> int: ...


@overload
def hard(arg0: Task, arg1: Task) -> AutoStack: ...


@overload
def hard(arg0: AutoStack, arg1: Task) -> AutoStack: ...


@overload
def hard(arg0: Task, arg1: AutoStack) -> AutoStack: ...


@overload
def hard(arg0: AutoStack, arg1: AutoStack) -> AutoStack: ...


@overload
def mul(arg0: numpy.ndarray[tuple[M, N], numpy.dtype[numpy.float64]], arg1: Task) -> Task: ...


@overload
def mul(arg0: float, arg1: Task) -> Task: ...


@overload
def sub(arg0: Task, arg1: list[int]) -> SubTask: ...


@overload
def sub(arg0: Constraint, arg1: list[int]) -> SubConstraint: ...


@overload
def subj(arg0: Task, arg1: Constraint) -> Task: ...


@overload
def subj(arg0: AutoStack, arg1: Constraint) -> AutoStack: ...


@overload
def subj(arg0: Task, arg1: Task) -> Task: ...


@overload
def subj(arg0: AutoStack, arg1: Task) -> AutoStack: ...


def sum(arg0: Task, arg1: Task) -> AggregatedTask: ...
